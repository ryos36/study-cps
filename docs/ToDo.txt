グローバル変数の扱い。

理想はクロージャとグローバル変数が区別されないこと。
すでに本実装ではグローバルな関数はクロージャを持つ関数と区別されていない。
つまり、グローバルな関数は最初の引数に疑似的なクロージャを持つ。

この疑似的なクロージャをより一般化して
コンパイル時に決定するグローバル変数を考慮する
疑似的なクロージャを作ることが出来る。

今は
main
    |:main|
exit
    |:exit|

みたいになっている。コンパイルしてバイナリになると
0x00000010: 0x00000040
0x00000014: 0x00000020
みたいな :main と :exit の関数のアドレスになる。
0x00000010 は :main 用のクロージャで main。
この値がクロージャとして第一引数にわたる。
じゃいっそのことその後にグローバル変数を入れればよい。

main
    |:main|
exit
    |:exit|
g0
    0
g1
    0

ここでは g0 に仮に 0 を入れておこう。そうすれば、グローバル変数という
概念はなくなりクロージャーだけの世界になる。

仮に define がグローバル変数の定義であり、同じ名前の define は
使ってはいけないという制約を課したとする(scheme 的には誤り)
そうすると
(define g0 <なんか計算>)
あるいは
(define g0 数字)
の2つがあり得るが、前者の場合、コンパイル時に g0 を決定できない。
後者の場合のみコンパイル時に決定できる。

なので、後者の場合のみ最適化しても(この場合の最適化はあらかじめ
値を知っていても）あまり効率的にはなりそうにないので
define は set! と等価であると考えてもよいだろう。
(本当か？これは現時点では scheme の規約を無視して
 グローバル変数の定義であると位置づけたから）
等価というのが気に入らなければかならず set! を含むと考えよう。

常に set! するなら、最初の同じ名前の define を使ってはいけない
という制約は外してもよさそう。同じ名前の define があって混乱するのは

(define g0 35)
と
(define g0 40)

と二つ書いてあった時に複数の定義があることになり、
コンパイル時の定数として決定出来ない自体が発生するからである。
define が set! を含むなら
(define g0)
(set! g0 35)
と
(define g0)
(set! g0 40)
と書いたのと同じになる。

となると、ここで set! を考慮したくなる。
しかし、私が作った mini-scheme はそもそも set! がない世界である。
実はそもそもクロージャがいらない。(つまりグローバル変数もいらない）
クロージャ内の書き換えが起こらないのですべてヴァリューで
レジスタ渡しをすればよい。

ということはクロージャー変換も実はいらない。全部、関数の引数で
渡してしまえばよかったのだ、、、、がははは。

(func (a b c) ... f ... )とあったら
(func-k (a b c f) ... f...)
と変換すればよい

それでは元も子もないので、set! を将来考慮すると考えて define を
あらためて見つめなおしてみる。

define があるローカル変数を書き換えるなら
(func (a b c) .... (define a <なにか>) ....)
ということは define よってあらたな定義は発生せず、
しかも単純に置き換えをしているだけでもある。これは let に置き換えられる。
(func (a b c) .... (let ((a <何か>)) ....))
とすればよい。
(func (a b c) .. f .. (define f <何か>).. f ..) と free 変数に
なにかしているのであれば set! ではあるがこれは record-set! と let 
に置き換えられる。
(func (a b c) .. f .. 
  (let ((f <何か>))
    (record-set! <fを含むクロージャ> <fのオフセット> f)
    ... f ...))
f は free 変数なのでどこかのクロージャがわたってきているはずだから。

define された変数がまったく新しい変数であれば
(func (a b c) .... (define new-v <何か>).. new-v ..) 
ローカル変数を定義したに過ぎないので let で置き換えられる。
(func (a b c) .... (let ((new-v <何か>)).. new-v ..))

グローバル変数の場合はその変数が readonly なのかどうかは
最後まで分からない(すくなくとも全部なめる必要がある）ため
ワンパスで処理するなら、ぜんぶ変更の可能性がある
クロージャ内の変数であると考える必要がある。

またすべてのグローバル関数の共通のクロージャがグローバル変数と
考えれば、main に先立ってあらかじめクロージャが決定していなければ
ならない。

グローバル変数をクロージャであるという立場をとった場合
(func (k a b c) .... g .... )
とあった場合、g は k からだどれる必要がある。
この場合、間接的なアクセスになるためその分、処理スピードに影響が
あるだろう。
また、各クロージャには結局グローバル変数の先頭アドレスが
伝播される。そこで、本実装ではグローバル変数を
特別扱いして :global-variable-pointer からのオフセットとする。

----------------------------------------------------------------
:ID の vm-codegen での暫定対応。
k-transfer の前に global 対応を新システムで行い、
eta-reduction を新システムに置き換え
その他オプティマイズを新システムに置き換え
順次新システムへと置き換える。
=> ということで :ID はいらなくなりつつある。

----------------------------------------------------------------
ToDo-1:k-transfer

APP が record-ref を要求し
record-ref が自由変数を持つとき

次のようなコード生成をする

(|:FACT| (FACT |sym18| K N)
  (:RECORD-OFF (FACT 1) (FACT0) ;<= FACT0 が自由変数のため FIXH で生成された部分
    ((:RECORD-REF (FACT0 0) (|k-sym3|) ;<= APP によって生成された部分
      ((:APP |k-sym3| (FACT0 |sym18| K N 1))))))))

これはさらに最適化可能
peephole ですべきかな？

(|:FACT| (FACT |sym18| K N)
  ((:RECORD-REF (FACT 1) (|k-sym3|) ;<= 統合可能
    ((:APP |k-sym3| (FACT0 |sym18| K N 1))))))))


----------------------------------------------------------------
ToDo-1:cps-transfer
イディオムに近いこのソースは

(:fix ((fact0 (k n rv)
          (:if (:= n 0)
               rv
               (fact0 k (:- n 1) (:* n rv))))

         (fact (k n)
           (fact0 k n 1)))

        (fact 10))

次のように変換されてしまう

(:FIXH
 ((|:FACT0| (FACT0 |sym11| K N RV)
   (:RECORD-REF (FACT0 1) (|sym22|)
    ((:= (N 0) NIL
      ((:RECORD-REF (|sym11| 0) (|sym23|) ((:APP |sym23| (|sym11| RV))))
       (:- (N 1) (|sym17|)
        ((:* (N RV) (|sym16|)
          ((:RECORD-REF (FACT0 0) (|sym24|)
            ((:APP |sym24| (FACT0 |sym11| K |sym17| |sym16|)))))))))))))
  (|:FACT| (FACT |sym18| K N)
   (:RECORD-REF (FACT 1) (|sym25|)
    ((:RECORD-REF (|sym25| 1) (FACT0)
      ((:RECORD-REF (FACT0 0) (|sym26|)
        ((:APP |sym26| (FACT0 |sym18| K N 1))))))))))
 (:HEAP ((:LABEL :DUMMY) FACT0) (|sym21|)
  ((:HEAP ((:LABEL |:FACT0|) |sym21|) (FACT0)
    ((:HEAP ((:LABEL |:FACT|) |sym21|) (FACT)
      ((:RECORD-REF (FACT 0) (|sym27|) ((:APP |sym27| (FACT EXIT 10)))))))))))

FACT の自由変数は FACT0 だけ。FACT0 には自由変数はない。
FACT0 を参照するのに二段階かかっている。
最適化できなくもない。比較的頻繁に出てくるイディオムなので
最適化した方がいいかも。=> さきおくり。

--------------------------------------------
DONE:cps-transfer
  cps-transfer で let のケースを最適化したつもり

元のソースは
    (:let ((x0-bit0 (get-bit0 x0))
           (x1-bit0 (get-bit0 x1)))
     (xor0
      (:- bit-n 1)
      (:+ n 1)
      (:>> x0 1)
      (:>> x1 1)
      (:+ rv (:<< (xor-bit x0-bit0 x1-bit0) n))))
だと xor にはじまり bit-n とか n x-0,x1 rv xor-bit までが自由変数で
FIXS の入れ子を作る。

        (:FIXS
         ((|sym27| (|sym28|)
           (:FIXS
            ((|sym25| (|sym26|)

x1-bit0 の最後だけ自由変数をとらえればいいのに
すべてについて自由変数をとらえてしまうので
こういうケースで異常に無駄な処理を作ってしまう。

    (:FIXS
     ((|:sym27| (|sym27| |sym28|)
       (:RECORD-REF (|sym27| 9) (BIT-N)
        ((:RECORD-REF (|sym27| 8) (N)
          ((:RECORD-REF (|sym27| 7) (X0)
            ((:RECORD-REF (|sym27| 6) (X1)
              ((:RECORD-REF (|sym27| 5) (RV)
                ((:RECORD-REF (|sym27| 4) (|sym13|)
                  ((:RECORD-REF (|sym27| 3) (XOR0)
                    ((:RECORD-REF (|sym27| 2) (XOR-BIT)
                      ((:RECORD-REF (|sym27| 1) (GET-BIT0)
                        ((:POP (10) NIL
                          ((:FIXS
                            ((|:sym25| (|sym25| |sym26|)
                              (:RECORD-REF (|sym25| 9) (BIT-N)
                               ((:RECORD-REF (|sym25| 8) (N)
                                 ((:RECORD-REF (|sym25| 7) (X0)
                                   ((:RECORD-REF (|sym25| 6) (X1)
                                     ((:RECORD-REF (|sym25| 5) (RV)
                                       ((:RECORD-REF (|sym25| 4)
                                       ....

これは関数コールがあるようなケースだ。
func(a b c)
   call func0
   call func0

   a b cを使う
このケースで

func(a b c)
   a b c を退避
   call func0
   a b c を復元
   a b c を退避
   call func0
   a b c を復元

   a b cを使う

という意味のないことをしてしまう。処理としてはあっている。
そこで、
FIXS の自由変数を つぎの FIXS が出てくるまでとした

    (:FIXS
        ......<ここが対象>.....
        (:FIXS
        ......

そうすることで、FIXS が単純に続くケースでは 内側の FIXS しか
Stack に積まない。あれ～大丈夫か？一応大丈夫そう。test-057.cps で確認。

FIXH や FIXS の組み合わせでいろいろなものがテストケースとして
足りないと思う。
