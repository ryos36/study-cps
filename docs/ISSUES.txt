----------------------------------------------------------------
ISSUES
    SPILL において不要な FIXH で宣言された引数も spill の対象にしている。
    使われていない場合は無視してよいので FIXH の引数は対象にしない方がよい?
    -> 解決したつもり 1/27
----------------------------------------------------------------
copy-tree/list はなるべく使わない方がよい。
    copy-tree/list に対して書き換える関数が定義されていると
    copy された瞬間にリンクを失う。
    例えば
        ... (:+ (<ARG0> <ARG1>) (<RV>) (....))) ...
        があり <ARG0> を置き換える関数があったとすると
        こぴされて
        ... (:+ (<ARG0> <ARG1>) (<RV>) (....))) ...
        と構成は同じものができるが先の関数はコピー前のリストに対する
        変換関数であるため。
        実際に let-transfer で問題が発生した
        let-transfer の延長で fix-transferがよばれ
        fix-transfer がコピー(copy-tree)してしまったために
        let-transfer の変数置き換えが機能しなかった。
        いまは fix-transfer の最後で copy するのをやめた

  でも結局 copy-tree は必須
    `(a b c) は必要ないが 
    `(a (b c)) は (b c) が共通になる
    `(a ,`(b c)) => okそう
    `(a (,b c))  => okそう

    clisp を検証してみた(仕様を確認すると実装依存だ、、、オーノー)
    `(a (,b 0))
　　定数が入ったている時に
    b/-> 0/nil
    の 0/nil を共有する。仕様を確認すると
　　`((,a b)...
     は (append (list a) (list 'b) nil) である。あるいは
     (append (list a) (list 'b)) あるいは
     (append (list a) '(b)) あるいは
     (cons a '(b)) あるいは
     (cons a (list 'b)) あるいは
     (cons a '(b))
     となっている。
     (append (list a) '(b)) が選択された場合
     '(b) を共有することになる。実装依存ということか？
     sbcl でも clisp でもそうだった。
     [1]> (defun f (a) `(a (,a z)))
     F
     [2]> (setf x0 (f 'x0))
     (A (X0 Z))
     [3]> (setf x1 (f 'x1))
     (A (X1 Z))
     [4]> (eq (cdadr x0) (cdadr x1))
     T
     なお、scheme では規定されていない模様。
     そうなるとますます copy-tree は必須。

scheme の複雑な closure にちゃんと対応しているか疑問
  closure の覚書参照の事。
　いまは fix で closure の元を env に関数名と共にポイントして置き
  app で copy-list で環境をコピーしている。
  copy-list であるため、情報は共有する。

scheme には /= がなかった
    mini-scheme では
    set! とかができないが
        set! は構文糖衣でできそうな気がする。
    なにを最小構成にするのかは scheme の規約で確認すべき。
    本格的な scheme を目指す。

define はスコープ破り
set! はスコープ破り(現時点の mini scheme は set! には対応していないが)
define は
    グローバル変数に対応しているのか？
    レジスタに対応しているのか？

