:READ
:LISP-TO-CPS
:ETA-REDUCTION
:CLOSURE-CONVERTER
:REORDER
:SPILL
:CODEGEN
:VMGEN

:let と :fix がクロージャの構造を決める。
(:let ((変数列...))
   処理)

で、変数のうち
ローカル変数: 置き換え
free になりえるが readonly: 関数の引数に増やす

     例：
     (:let ((vf0 3))
        (:define (f a b)
            ....
            (+ vf0 a)
            ....)
        ...
        (f 0 1)
        ...
        (f 2 3)
        ...)

    次と等価

    (:define (f a b vf0)
            ....
            (+ vf0 a)
            ....))
    (f 0 1 3)
    ...
    (f 2 3 3)
    ...)

free になりえて書き換わる: クロージャとして heap が必要

---------------------
(:let ((a 0) (b 1) (c 2))
   ....)
は意味的に
(:fix <let由来> ((|:sym0| (a b c)
          .....))
   (:app |:sym0| (0 1 2))
であるが処理的に最後はまた元に戻して
:app が消えるので、そのまま :let を引き継ぐことにする。

---------------------
そういう意味ですべてのクロージャの構造は :fix で決まる。

構造は :fix で決まるが生成は :app の直前におこなわれる。

(:fix ((f ...
   (:fix ((g ....
          (g1 ...
      (:fix ((h ....

とあった時に g に app するときは f と g のクロージャを作る。
よばれた g では自分がどの free 変数を必要とするかを知っている必要がある。

(:fix ((f ...
   (:meta (g vf0 vf1 f) ....
       (:fix ((g ....
              (g1 ...
           (:meta (h ....
                   (:fix ((h .....
                           (:if (< a b) 
                            (h (4))
                            (g (3))))))))
のように g と h に関するメタ情報が必要。
g をよぶときは g が要求するクロージャの構造
h をよぶときは h が要求するクロージャの構造
を app に変換する直前で生成する必要がある。

さらに h は f1 を呼ぶかもしれない。

(:fix ((f (... vf2... ) ...
   (:meta (g vf0 vf1 f) (g1 ... vf2 ...)
       (:fix ((g ....
              (g1 (a) ... vf2 ....
           (:meta (h ... g1)
                   (:fix ((h ... (g1 3)...
                           (:if (< a b) 
                            (h (4))
                            (g (3))))))))

h は間接的に vf2 を必要とする。したがって、 h を呼ぶ際には
vf2 を含むクロージャーも渡さないといけない。
どのクロージャーを含むかは free 変数となっている関数を追う必要がある。
呼ばれる側の g1 は vf2 をクロージャから取り出すようにする必要がある。

あーちがうかも
(let (a b c)
  (fix ...
  ...
  (fix ...
  ...

とあったばああい a b c のクロージャは共用されなければならない。
fix のなかで heap してしまうと
(let (a b c)
  (fix ...

      (heap (a b c) (r0) ((app ...
  ...
  (fix ...
  ...
      (heap (a b c) (r1) ((app ...

となり共用できない。
つまり使われるか使われないかは関係なく let や fix の先頭で
クロージャは作られるべき。
(let (a b c)
  (heap (a b c) (r0) ....

  (fix ...

      (heap (... r0) (r1) ((app ...
  ...
  (fix ...
  ...
      (heap (... r0) (r2) ((app ...

となるべき。そして fix が一つの場合は無駄だけど次のようにするか？

(let (a b c)
  (heap (a b c) (r0) ....

  (fix ...

      (heap (... r0) (r1) ((app ...


あるいはうまく最適化して

(let (a b c)

  (fix ...

      (heap (... a b c) (r0) ((app ...

とする。 そのためには fix にメタ情報が必要で

(let (a b c)
  (:meta ( こうぞくにどんな free 変数を使うか情報 )
    (fix ...

      (heap (... a b c) (r0) ((app ...

で後続は free 変数がないという確信が得られたら最適化してよい。
