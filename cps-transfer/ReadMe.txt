let を変換するときに let 内でコードウォークせずにうまく変換できた。
context という概念を導入する。
context は 継続 + レキシカルスコープ

; context := (continuation-lambda . (tablen ... table1 table0))
tablen から table0 はレキシカルスコープのハッシュ
継続は関数になっている。
プレスフォルダーを埋める関数
例えば
(+ arg0 arg1)
とあれば
k1 <= (+ (<arg0> <arg1>) [r] kont)) を埋める"関数"
このとき kont は 
context の (kont-lambda . ....) でわたってきている関数より生成される。
r は + の中で作られる。例えば r125 が生成されたとすると
kont = (kont-lambda 'r125)
で得られる r125 を埋めて
k1 <= <arg1> を埋める関数 (+ (<arg0> <arg1>) [r125] kont)
これが k0 への継続になる。 k0 は
k0 <= <arg0> を埋める関数で
k1 の継続とともに評価される。

-----------------------------------------------------------------
(let (.....) (....))
の変換について

(let ((a0 (処理0)) (a1 (処理1)) ... (an (処理n))) 
  (主処理0)
  (主処理1)
  (主処理2)
  (主処理3)
  ...
  ...
  ...
  ...
  (主処理m))

を変換するときにまず、hash-table をつくる。
ここに各let 内のローカル変数を nil で登録する。
この時点では各ローカル変数の置換すべきシンボルは決定していない。

次に継続をつくる（つまり後の処理を先に作る必要あり)ために
主処理 m から処理をする。

単純に処理をしていけばよいが、主処理の中で
シンボルの評価をするような時がある。
例えば (:+ a0 a1)
a0 a1 はこの let 内のローカル変数。
通常は a0 a1 をそのまま返せばよいのだが、変換テーブルに a0 a1 が
あるので、変換しなければならないことがわかる。
しかし、この時点で変換してしまうと、シンボル名が決定してしまう。
例えば、(:+ sym0 sym1) -> (:+ (sym0 sym1) (r) ((....r....)))
なので、このとき :+ は a0 を評価しようとして sym0 を入れてほしいと
いう lambda 関数を context に入れている。
つまり (:+ ( <PLACE-HOLDER> sym1) (r) ((....r....))) にいれてという
lambda を context にいれている。これを a0 の変換テーブルに入れる。

最終的に (主処理m) ... (主処理0) まで a0 が使われるたびに
変換テーブルに lambda が蓄積される(cons で蓄積する)。

ここまでで、全ての主処理と let に先立つ継続が決定しているが、
<PLACE-HOLDER> は埋まっていない。
また各変換テーブルには直接的に <PLACE-HOLDER> を埋める
lambda が蓄積されている。

次に引数を逆順に処理する
(an (処理n))
処理n の延長では最終的に結果を格納すべきシンボルが決定する。
そのシンボル名で通常は context に登録された lambda がよばれ
その lambda の中で PLACE-HOLDER が埋められる。
いま an に関連する lambda は複数あり、それは変換テーブルに
an の名前で複数登録されている。
そこで、いったん let のローカル関数でこの lambda を受けて
テーブルから an に関連する lambda をすべて呼ぶ。
lambda の引数は 処理n 内で決定したシンボル名1つ。
必要な情報はその他に an というシンボル名称(どの lambda 群を呼ぶか？)
とテーブル。これはクロージャーで関数内に閉じ込めてしまえばよい。
(最初はこのアイデアの実現にグローバル変数でシミュレートした)

a0 まで処理すると PLACE-HOLDER はなくなっているはずだ。

