scheme の変数と関数の一意性が let の cps 変換の時に生きる。
と思ってたが、コードウォークせずにうまく変換できた。

(let (.....) (....))
の変換について

(let ((a0 (処理0)) (a1 (処理1)) ... (an (処理n))) 
  (主処理0)
  (主処理1)
  (主処理2)
  (主処理3)
  ...
  ...
  ...
  ...
  (主処理m))

を変換するときにまず、hash-table をつくる。
ここに各let 内のローカル変数を nil で登録する。
この時点では各ローカル変数の置換すべきシンボルは決定していない。

次に継続をつくる（つまり後の処理を先に作る必要あり)ために
主処理 m から処理をする。

単純に処理をしていけばよいが、主処理の中で
シンボルの評価をするような時がある。
例えば (:+ a0 a1)
a0 a1 はこの let 内のローカル変数。
通常は a0 a1 をそのまま返せばよいのだが、変換テーブルに a0 a1 が
あるので、変換しなければならないことがわかる。
しかし、この時点で変換してしまうと、シンボル名が決定してしまう。
例えば、(:+ sym0 sym1) -> (:+ (sym0 sym1) (r) ((....r....)))
なので、このとき :+ は a0 を評価しようとして sym0 を入れてほしいと
いう lambda 関数を context に入れている。
つまり (:+ ( <PLACE-HOLDER> sym1) (r) ((....r....))) にいれてという
lambda を context にいれている。これを a0 の変換テーブルに入れる。

最終的に (主処理m) ... (主処理0) まで a0 が使われるたびに
変換テーブルに lambda が蓄積される(cons で蓄積する)。

ここまでで、全ての主処理と let に先立つ継続が決定しているが、
<PLACE-HOLDER> は埋まっていない。
また各変換テーブルには直接的に <PLACE-HOLDER> を埋める
lambda が蓄積されている。

次に引数を逆順に処理する
(an (処理n))
処理n の延長では最終的に結果を格納すべきシンボルが決定する。
そのシンボル名で通常は context に登録された lambda がよばれ
その lambda の中で PLACE-HOLDER が埋められる。
いま an に関連する lambda は複数あり、それは変換テーブルに
an の名前で複数登録されている。
そこで、いったん let のローカル関数でこの lambda を受けて
テーブルから an に関連する lambda をすべて呼ぶ。
lambda の引数は 処理n 内で決定したシンボル名1つ。
必要な情報はその他に an というシンボル名称(どの lambda 群を呼ぶか？)
とテーブル。これはクロージャーで関数内に閉じ込めてしまえばよい。
(最初はこのアイデアの実現にグローバル変数でシミュレートした)

a0 まで処理すると PLACE-HOLDER はなくなっているはずだ。

