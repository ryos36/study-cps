cps-to-lisp を評価するときにの環境は
(シンボル . シンボルを含む cps の継続)
となっている。
シンボルは継続で使われる引数
----------------------------------------------------------------
if で continuation が複製されてしまう。
----------------------------------------------------------------
CPS ではある処理をさせようとしたときに、
すでに、その処理の後に"継続する"処理も一緒に渡す。

そのとき、後続の処理(=継続) ではそのある処理の結果を
使う事になるだろう。

ある処理から継続にどれだけ情報が引き渡されるかわからないので、
引数は１つとする。

つまり、継続を関数とみると
continuous(r)
という関数になる。

継続内ではその r を有効に使う事になる。

ただし、純粋な関数ではないので r という変数があって、
呼び出し元(ある処理)の変数を呼び出し先(継続)の変数で
置き換えてくれるわけではない。

繰り返しになるが、関数呼び出しなら
rv = 3 + 5;
continuous(rv)
とし、
continuous の宣言では
continuous(r)
{
        r が使われる
}
と書かれた場合、rv は r に(意味的には)置き換えて処理される。

CPS はそうはなっていない。
(ある処理 (ある処理の引数...) (r) ((...継続...)))
となり、...継続... 中で r が使われる。
つまりある処理を呼ぶ前に、継続で使われる変数 r が決定してまう。

例えば (:exit (r) () ()) という継続があったらこの時点で、
r が決定している。ある処理には、変数名と継続の２つを渡してあげる
ことになる。
つまり
r と (:exit (r) () ())

ある処理は(たとえば足し算だったとすると)
その結果を r に入れる。

(:+ (a0 a1) (r) (...継続...))

継続は (:exit (r) () ())
なので、結果として
(:+ (a0 a1) (r) (:exit (r) () ()))
を得る。

ある処理が ID (シンボルや数字)だったときに問題が起こる。
単純に数字だったとする。
lisp では
(exit 5)
のようになる。これを CPS 変換しようとすると、
まず exit が変換されるであろう。結果として、
r と (:exit (r) () ())
を得る。次に 5 が変換されるが、すでに exit は変換済みで、
r という変数名が決定されてしまっている。
そこで、id というエッセンシャル(?) を導入して

(:id (5) (r) ((:exit (r) () ())))

とする。しかし直感的には (:eixt (5) () ())
になってほしいのだ。
(exit (+ 3 5))
は(:+ (3 5) (r) ((:exit (r) () ()))) になってほしいが、
id を導入することにより
(:id (3) (r0) 
  ((:id (5) (r1) 
    ((:add (r0 r1) (r)
      ((:exit (r) () ())))))))
となる。かなり冗長だ。


