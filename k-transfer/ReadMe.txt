free-variable-finder.lisp
  指定された cps のしたを単純にサーチし
    env の直下に
    (v0 . t)
    (v1)
  　のリストをつくる。 t なら宣言されている。
    nil なら宣言されていない = free
    env はネストしない
  つまり env 内の変数リストは
   ((v0 . t) (v1) (v2) (v3 .t))
  のようになる。
  子供に FIX があるかどうか問題にしない。
  親の FIX に関連してがかならず heap あるいは stack をつくるため。
    
closure-converter.lisp
  上とは違う方法で変数を管理
  env は次のようになるので注意が必要
; FIXH の場合 ((:fixh . closure-sym) v0 v2 ....)
; FIXS の場合 ((:fixs ) v0 v2 ....)
; primitive の場合 ((:primitive . <実際のop> ) v0 v2 ....)

  FIX[S/H](以下 FIX) がでてくるとまず単純に管理下の free-vars を数え上げる。
  管理下とは FIX で規定されている関数の宣言の中。
  関数宣言のなかは必ず最後は APP で終わる。
  また、その途中に APP はない。
  
　クロージャーは FIX で宣言されるすべての関数に共用されるため
　binds に含まれる free-vars をまずは列挙する。

  しかし、これは上の FIX ですでに heap 済みかもしれない
　つまり入れ子になっている FIX の場合は親の FIX での free-vars は
  そこと共用される。

  そこで、いままで登録された FIX[S/H] を env から逆順にたどり
  そこにはいっていたら free-vars から削る

  結果として該当する FIX での free-vars のみがわかる。
  (同じ変数は上位の FIX で共有する。違う階層の共有)

  この heap を FIX(SもHも) FIX の本体の先頭で作る。
  recored-ref は関数内の先頭ですべてのクロージャ内の宣言している。
  FIXS ではすべて使われるはずなので使われいことをチェックしていない。
  FIXH では使われていない変数は recored-ref しないようチェックしている。
  
  使う際には fixs の場合はすぐに bind のなかでレジスタに復元して pop する。

  fixh ならさらにその一つの bind のなかで free-vars を探し
  bind 内の先頭で record-ref する。app は最後まで行かないとないので
  ここで record-ref してもスレッド対応を考えてもそれでよい。
　もし、厳密には致したいなら OS などで mutex を使わなくてはならないが
　コンパイラの仕事ではないので対応しない。

  どのタイミングで参照される"べき"かはコンパイラは知りようがないので
  FIXで定義される関数本体の最初で record-ref して問題ない。
  record-ref は遅延させて参照した方がよい場合もあるだろうが、
　これらはのちのスケジューリングで最適化されるのでここでは考慮しない。

  また fixh では該当する fixh に複数の bind があった場合に共有する
  (同階層の共有)
　そのため fixh では heap が二段階になっている。
  たとえば
  (FIXH ((f0 (a0 a1) (..... v0 .....))
         (f1 (a0 a1) (..... v1 .....)))
        (..FIX本体..))
  で v0 v1 が free-vars なら
  (heap ((:dummy) v0 v1) (|sym0|) ((....)))
  が生成される。さらに f0 と f1 のクロージャが生成され
  (heap ((:dummy v0 v1) (|sym0|)
    ((heap ((:label |f0|) |sym0|) (f0)
      ((heap ((:label |f1|) |sym0|) (f1)
         ((..FIX本体..))))))))
  となる。
  なお 関数が一つであった場合は 1つにする最適化をしている。
  (heap ((:label |f0-only|) v0 v1) (f0-only)
     ((..FIX本体..)))

  上位に FIXH があった場合はさらに複雑になるここでは簡略化して説明する
  (FIXH ((f0 (a0 a1) (..... v0 .....)))
      (..  FIX本体 f0 ...
         (FIXH ((f1 (a0 a1) (..... v0 ... v1 .....)))
            (..  FIX本体 f1 ...))))

   この場合 f1 の free-vars は v0 v1 だがすでに上位の v0 があるので
  (heap ((:label |f0|) v0 ) (f0)
        ((... FIX本体 f0)))
  というクロージャが存在する。
　そこで f1 のクロージャーは
    (heap ((:label |f1|) v1 f0 ) (f1)
          ((... FIX本体 f1)))
  となる。
　参照する際は
   (record-ref (f1 1) (v1)
    ((recored-ref (f1 2) (f0) 
      ((recored-ref (f0 1) (v0)
          ((.... v0 ..... v1 ....)))))
  となる。
  これで fixh に複数の関数定義があるとさらに複雑化されるが
  すべて事前にわかることなのでコンパイラで対応可能である。
  さらに FIX で宣言される f1 などで変数が隠ぺいされていた場合

  (FIXH ((f0 (a0 a1) (..... v0 .....)))
      (..  FIX本体 f0 ...
         (FIXH ((f1 (a0 a1 v0) (..... v0 ... v1 .....)))
            (..  FIX本体 f1 ...))))

  例えば上の v0 は f1 内では自由変数ではない。
  そのためこれらの宣言がある場合は ((:primitive . op) ... v0....)
  という環境を用意して隠ぺいする。
  宣言は
  binds 内の　関数名、引数
  primitive の結果
  が考えられ、それが考慮されている。

  
