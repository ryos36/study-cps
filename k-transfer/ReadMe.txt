fix の考え方
　 (fix[s|h] ((f0 (a0 a1 ...) (....F0 AREA....))
              (f1 (b0 b1 ...) (....F1 AREA....)))
    (....FIX AREA....))

F0 AREA は f0(関数名) a0, a1, ...(引数) は既知なので自由変数にならない
  F0 AREA では f1 は自由変数
F1 AREA は f1(関数名) b0, b1, ...(引数) は既知なので自由変数にならない
  F1 AREA では f0 は自由変数
FIX AREA では　f0, f1 （関数名) は既知なので自由変数にならない

FIXでつくるクロージャは F0 AREA と F1 AREA の自由変数 で F0 F1 に影響
   FIX AREA の自由変数は誰かが上で作っているであろう。

FIX 内(上記 FIX AREA 含む)の誰かが"おなじ" FIX 内の別の関数を呼ぶときは
クロージャをもってよぶことになる。
各関数が呼ばれあうことはあるが、最初によぶのはどうやっても
FIX AREA 経由になるので最初に FIX AREA で HEAP を使いクロージャを作る。
クロージャは各関数で共有されるので、各関数の自由変数を合算したものとなる。

FIXS の場合、

　 (fixs ((f0 (a0 a1 ...) (....f0 AREA....))
    (....(:app f0 (...) ....)

の形式しかありえないので(複数の関数定義はない)
呼び出し前に STACK によりクロージャを作る。

;----------------------------------------------------------------
get-ordered-func-name
呼び出し順になるべく並ぶようにトポロジカルソートをする
呼び出し順になると record-offs が楽になる。
相互呼び出しをしていると
    record-offs にマイナスを使うか(こちら方式はいまのところ不採用)
    一旦、0 を入れてから record-set! でいれる(この方式。ださいかも）
;----------------------------------------------------------------
free-variable-finder.lisp
  指定された cps のしたを単純にサーチし
    env の直下に
    (v0 . t)
    (v1)
  　のリストをつくる。 t なら宣言されている。
    nil なら宣言されていない = free
    env はネストしない
  つまり env 内の変数リストは
   ((v0 . t) (v1) (v2) (v3 .t))
  のようになる。
  子供に FIX があるかどうか問題にしない。
  親の FIX に関連してがかならず heap あるいは stack をつくるため。
  なぜかここだけ tagged-list じゃない

  次のケースで問題があったので、一部、階層的な env を取り入れた。

 (:fixh ((g0 (k0 b1) (:* (ex-g0 sym0) (sym1) (
          (:+ (b1 sym1) (ex-g1) (
           (:app k0 (ex-g1)))))))

          (g1 (k2 b2) (:+ (ex-g1 ex-g2) (sym5) (
          (:app f0 (sym5))))))  
        (:- (ex-c ex-d) (sym3) (
           (:app g0 (ex-k sym3)))))

  このケースでは g1 で ex-g1 が使われていて自由変数だ。
　g0 で ex-g1 が宣言的に使われているので g0 内では ex-g1 は
  名前が予測させる変数と違いただのローカル変数だ。
　g0 を評価した時点で all-variables として (ex-g1 . t) が登録されてしまい
  g1 を評価した時に自由変数にならない。
  そこで binds のときのみ階層化して、戻ってきたときに
  new-env から自由変数だけを取り出して env に付け加えるようにした。

  将来構想としては env に自由変数を append することで env 内に
  自由変数を蓄積可能。(car env) でたどれるのが階層的な env で
  再帰的に (car env) を取得しながら find-variable で変数を探せる。
  env がなくなるか、 (car env) が atom になった場合は環境ではないので
  find-variable は nil を返す。
  find-variable はすでにこの実装がなされれているが、
　実際に実装しようと思えば、この場合すべての階層に対して
  なんらかの階層的な環境設定をする必要があるかもしれない。
  ので実装は中途半端。
  恐らく bind だけが分岐するので、現在の実装で十分と思われる。
  [ToDo] 比較演算子も分岐するのだけど大丈夫か？=> 大丈夫じゃない

  => あほでした。ネストする情報に env を使うべき。
     静的な情報は slot にためるのがよい。
    
;----------------------------------------------------------------
closure-converter.lisp
  上とは違う方法で変数を管理
  env は次のようになるので注意が必要
; FIXH の場合 ((:fixh . closure-sym) (:fixh . closure-sym) ... v0 v2 ....)
; FIXS の場合 ((:fixs ) v0 v2 ....)
; ここで列挙されるのは自由変数
; 想定しているのは FIX .... FIX....
; と入れ子になっている場合に上位の FIX で宣言されているものは含まないように
; すること
; 例えば FIX ... v1 ... FIX ... v1 ....
; この場合 v1 は再外層のクロージャで v1 が共有される。

; primitive 或いはbind の場合 途中でせんげんがあるので注意が必要だ
; ここで列挙されるのは宣言された変数
; たとえば FIX .... v1 ... ......(:FIX ((v1 (a b) (.... FIX .... v1
; の場合最外層の FIX でも v1 のクロージャが生成される
; 中間の FIX は宣言なのでクロジャーは生成されない
; 最内層の FIX でもクロージャが生成されこれは上位の v1 とは共有されない

[注意] 本格的に確認していないが primitive で cps 変換時に生成される
シンボルは一意性がなくてはならない(FIX の関数名や引数とかぶらない)
本実装がそうなっているのは当然だが、CPS を自分で手で作るときも
CPS の仕様上、同じ変数へ代入できない(代入できると SSA のようにならない)
結局、現時点での mini-scheme の変数の宣言は define fix let で
cps 変換されると define -> fixh, fix -> fixh, let -> 置き換え
となるので fixh しかない。
気になる fixs は if と app の時に
1 引数の 1 関数が生成され、いずれのシンボルも自動生成
[注意というか実装した後気が付いた]

  FIX[S/H](以下 FIX) がでてくるとまず単純に管理下の free-vars を数え上げる。
  管理下とは FIX で規定されている関数の宣言の中。
  関数宣言のなかは必ず最後は APP で終わる。
  また、その途中に APP はない。
  
　クロージャーは FIX で宣言されるすべての関数に共用されるため
　binds に含まれる free-vars をまずは列挙する。

  しかし、これは上の FIX ですでに heap 済みかもしれない
　つまり入れ子になっている FIX の場合は親の FIX での free-vars は
  そこと共用される。

  そこで、いままで登録された FIX[S/H] を env から逆順にたどり
  そこにはいっていたら free-vars から削る

  結果として該当する FIX での free-vars のみがわかる。
  (同じ変数は上位の FIX で共有する。違う階層の共有)

  この heap を FIX(SもHも) FIX の本体の先頭で作る。
  recored-ref は関数内の先頭ですべてのクロージャ内の宣言している。
  FIXS ではすべて使われるはずなので使われないことをチェックしていない。
  FIXH では使われていない変数は recored-ref しないようチェックしている。

  使う際には fixs の場合はすぐに bind のなかでレジスタに復元して pop する。

  FIXH では各 binds の関数で共通の領域を record-offs をつかいずらして
  使うようにしている。たとえば、f0 g0 があり、自由変数が v0 v1 なら
  <label :f0> <label :g0> v0 v1 
  がクロージャーとして heap 領域を持つ。
  f0 からは v0 は record-ref の offset 2 の変数となるつまり
  (record-ref (f0 2) (v0) (....
  g0 からは v0 は record-ref の offset 1 の変数となる。
  
  各関数が参照していた場合は複雑になる。相互参照でない場合は
  参照を考慮してクロージャの順序がが決まる。
  例えば fact が fact0 を使うなら
  <label :fact> <label :fact0> v0 v1
  となり、fact 内で fact0 は record-off で参照可能となる。
  (record-off (fact 1) (fact0) (....

　そのために FIXH では free-vars を使い各 binds の関数の参照関係を把握して
  いる。

  また、各関数が相互参照している場合は record-set! も使う必要がある。
  典型的だが効率の悪い odd? even? の相互参照は
  <label :odd?> <label :even?> :#f が最初ヒープにとられる。
  :#f は odd? を入れたいところだが、まだ生成されていないので入れようがない。
  (heap (<label :odd?> <label :even?> :#f) (odd?) (....
  となり
  (recored-set! (odd? 2 odd?) () (....
  で完成する。
  
  fixh ならさらにその一つの各 bind のなかで free-vars を探し
  bind 内の先頭で record-ref あるいは record-offs をする。
  ここで record-ref してもスレッド対応を考えてもそれでよい。
　もし、厳密には致したいなら OS などで mutex を使わなくてはならないが
　コンパイラの仕事ではないので対応しない。

  たとえば、最終的に (:app fact (n))
  のような場合、fact が binds で宣下されていた場合、
  は自由変数ではないがクロージャ変換として heap でそのクロージャを作る。
  これらの binds 時の関数は生成される変数なので record-off で生成する。
  使われない変数は生成しない。

  上記のサイクリックに使う場合の record-set! で代入すべきシンボルは
  使われる場合は record-off で生成済みなので、そのシンボルを使うが、
  使わない場合は新たにシンボルをつくる。つまり
  (record-offs (closure <n>) (|new-sym|)
    ((record-set! (|new-sym| <m> closure) (...
  のケースと
  (record-offs (closure <n>) (fact0)
    ((record-set! (fact0 <m> closure) (...
  のケースが存在する

  どのタイミングで参照される"べき"かはコンパイラは知りようがないので
  FIXで定義される関数本体の最初で record-ref して問題ない。
　が最適化の余地は残る例えば、、、
==============================================(はじまり)
APP が record-ref を要求し
record-ref が自由変数を持つとき

次のようなコード生成をする

(|:FACT| (FACT |sym18| K N)
  (:RECORD-OFF (FACT 1) (FACT0) ;<= FACT0 が自由変数のため FIXH で生成された部分
    ((:RECORD-REF (FACT0 0) (|k-sym3|) ;<= APP によって生成された部分
      ((:APP |k-sym3| (FACT0 |sym18| K N 1))))))))

これはさらに最適化可能

(|:FACT| (FACT |sym18| K N)
  ((:RECORD-REF (FACT 1) (|k-sym3|) ;<= 統合可能
    ((:APP |k-sym3| (FACT0 |sym18| K N 1))))))))
==============================================(おしまい)

  record-ref は遅延させて参照した方がよい場合もあるだろうが、
　これらはのちのスケジューリングで最適化されるのでここでは考慮しない。

  また fixh では該当する fixh に複数の bind があった場合に共有する
  (同階層の共有)
　そのため fixh では heap が二段階になっている。
  たとえば
  (FIXH ((f0 (a0 a1) (..... v0 .....))
         (f1 (a0 a1) (..... v1 .....)))
        (..FIX本体..))
  で v0 v1 が free-vars なら
  (heap ((:dummy) v0 v1) (|sym0|) ((....)))
  が生成される。さらに f0 と f1 のクロージャが生成され

  (heap ((:label |f0|) (:label |f1|) v0 v1) (f0) (...
  (record-off (f0 1) (f1) (...
  となる。
  これで関数が1つでも２つ以上でもおなじようにでも対応できる。

  bind 側では ((:fixh . f0) (:fixh . f1) v0 v1)という情報がわたるので、
  f0 が f1 を参照しようとした場合は
  (record-offs (f0 1) (f0) (...
  で v0 の場合は 
  (record-ref (f0 2) (v0) (...
  となり record-offs と record-ref をうまく切り分けるようにしている。

  相互参照の場合は ((:fixh . odd?) (:fix . even?) odd?) がわたるので
  odd? が even? を参照する場合は
  (record-offs (odd 1) (even?) (...
  で even? が参照する場合は
  (record-ref (even? 1) (odd?) (...
  #う～ん。よくよく考えると record-offs にマイナスを許せばよかったのか。
  #そうすると相互参照を解析する必要もなかったのか、、、、

  上位に FIXH があった場合はさらに複雑になるここでは簡略化して説明する
  (FIXH ((f0 (a0 a1) (..... v0 .....)))
      (..  FIX本体 f0 ...
         (FIXH ((f1 (a0 a1) (..... v0 ... v1 .....)))
            (..  FIX本体 f1 ...))))

   この場合 f1 の free-vars は v0 v1 だがすでに上位の v0 があるので
  (heap ((:label |f0|) v0 ) (f0)
        ((... FIX本体 f0)))
  というクロージャが存在する。
　そこで f1 のクロージャーは
    (heap ((:label |f1|) v1 f0 ) (f1)
          ((... FIX本体 f1)))
  となる。
　参照する際は
   (record-ref (f1 1) (v1)
    ((recored-ref (f1 2) (f0) 
      ((recored-ref (f0 1) (v0)
          ((.... v0 ..... v1 ....)))))
  となる。
  これで fixh に複数の関数定義があるとさらに複雑化されるが
  すべて事前にわかることなのでコンパイラで対応可能である。
  さらに FIX で宣言される f1 などで変数が隠ぺいされていた場合

  (FIXH ((f0 (a0 a1) (..... v0 .....)))
      (..  FIX本体 f0 ...
         (FIXH ((f1 (a0 a1 v0) (..... v0 ... v1 .....)))
            (..  FIX本体 f1 ...))))

  例えば上の v0 は f1 内では自由変数ではない。

  fixh と fixs は別々の話なので、本来は同時に環境内にいれてはならない。
  fixs でいれる自由変数は直後で使われる。

また、
  (FIXH ((f0 (a0 a1) (..... v0 .....)))
      (..  FIX本体 f0 ...

         (<primitive> <(args)> (v1) ((....

         (FIXH ((f1 (a0 a1 v0) (..... v0 ... v1 .....)))
            (..  FIX本体 f1 ...))))

というケースも考慮している。
このケースは CPS の文法の範囲内である。(?)
(ただしこのプロジェクトの cps-transfer は上記のようなものは生まない
 test ケースにはある)

この場合、外郭の FIXH は v1 を自由変数に含まない。

次は CPS の仕様上あってはならない(はず)
いずれも同じ v1 に代入しているため

ケース1
(FIXH ((g0 (v0 v1) (........)))

  (FIXH ((f0 (a0 a1) (..... v0 .....)))
      (..  FIX本体 f0 ...

         (<primitive> <(args)> (v1) ((....

         (FIXH ((f1 (a0 a1 v0) (..... v0 ... v1 .....)))
            (..  FIX本体 f1 ...))))

ケース2
(<primitive> <(args)> (v1) ((....

  (FIXH ((f0 (a0 a1) (..... v0 .....)))
      (..  FIX本体 f0 ...

         (<primitive> <(args)> (v1) ((....

         (FIXH ((f1 (a0 a1 v0) (..... v0 ... v1 .....)))
            (..  FIX本体 f1 ...))))
