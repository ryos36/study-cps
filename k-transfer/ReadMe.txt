fix の考え方
　 (fix[s|h] ((f0 (a0 a1 ...) (....F0 AREA....))
              (f1 (b0 b1 ...) (....F1 AREA....)))
    (....FIX AREA....))

F0 AREA は f0(関数名) a0, a1, ...(引数) は既知なので自由変数にならない
  F0 AREA では f1 は自由変数
F1 AREA は f1(関数名) b0, b1, ...(引数) は既知なので自由変数にならない
  F1 AREA では f0 は自由変数
FIX AREA では　f0, f1 （関数名) は既知なので自由変数にならない

FIXでつくるクロージャは F0 AREA と F1 AREA の自由変数 で F0 F1 に影響
   FIX AREA の自由変数は誰かが上で作っているであろう。

;----------------------------------------------------------------
free-variable-finder.lisp
  指定された cps のしたを単純にサーチし
    env の直下に
    (v0 . t)
    (v1)
  　のリストをつくる。 t なら宣言されている。
    nil なら宣言されていない = free
    env はネストしない
  つまり env 内の変数リストは
   ((v0 . t) (v1) (v2) (v3 .t))
  のようになる。
  子供に FIX があるかどうか問題にしない。
  親の FIX に関連してがかならず heap あるいは stack をつくるため。

  次のケースで問題があったので、一部、階層的な env を取り入れた。

 (:fixh ((g0 (k0 b1) (:* (ex-g0 sym0) (sym1) (
          (:+ (b1 sym1) (ex-g1) (
           (:app k0 (ex-g1)))))))

          (g1 (k2 b2) (:+ (ex-g1 ex-g2) (sym5) (
          (:app f0 (sym5))))))  
        (:- (ex-c ex-d) (sym3) (
           (:app g0 (ex-k sym3)))))

  このケースでは g1 で ex-g1 が使われていて自由変数だ。
　g0 で ex-g1 が宣言的に使われているので g0 内では ex-g1 は
  名前が予測させる変数と違いただのローカル変数だ。
　g0 を評価した時点で all-variables として (ex-g1 . t) が登録されてしまい
  g1 を評価した時に自由変数にならない。
  そこで binds のときのみ階層化して、戻ってきたときに
  new-env から自由変数だけを取り出して env に付け加えるようにした。

  将来構想としては env に自由変数を append することで env 内に
  自由変数を蓄積可能。(car env) でたどれるのが階層的な env で
  再帰的に (car env) を取得しながら find-variable で変数を探せる。
  env がなくなるか、 (car env) が atom になった場合は環境ではないので
  find-variable は nil を返す。
  find-variable はすでにこの実装がなされれているが、
　実際に実装しようと思えば、この場合すべての階層に対して
  なんらかの階層的な環境設定をする必要があるかもしれない。
  ので実装は中途半端。
  恐らく bind だけが分岐するので、現在の実装で十分と思われる。

  => あほでした。ネストする情報に env を使うべき。
     静的な情報は slot にためるのがよい。
    
;----------------------------------------------------------------
closure-converter.lisp
  上とは違う方法で変数を管理
  env は次のようになるので注意が必要
; FIXH の場合 ((:fixh . closure-sym) v0 v2 ....)
; FIXS の場合 ((:fixs ) v0 v2 ....)
; ここで列挙されるのは自由変数
; 想定しているのは FIX .... FIX....
; と入れ子になっている場合に上位の FIX で宣言されているものは含まないように
; すること
; 例えば FIX ... v1 ... FIX ... v1 ....
; この場合 v1 は再外層のクロージャで v1 が共有される。

; primitive 或いはbind の場合 ((:primitive . <実際のop> ) v0 v2 ....)
; ここで列挙されるのは宣言された変数(自由変数ではない)
; 想定しているのは FIX ... primiteive or (FIX) bind .... FIX
; で (bind は当然 FIX が上位にあるのだが)
; 中間の primitive や bind 内に下位の自由変数の宣言があること。
; たとえば FIX .... v1 ... ......FIX bind v1.... FIX .... v1
; の場合最外層の FIX でも v1 のクロージャが生成される
; 中間の FIX は宣言なのでクロジャーは生成されない
; 最内層の FIX でもクロージャが生成されこれは教諭されない

  FIX[S/H](以下 FIX) がでてくるとまず単純に管理下の free-vars を数え上げる。
  管理下とは FIX で規定されている関数の宣言の中。
  関数宣言のなかは必ず最後は APP で終わる。
  また、その途中に APP はない。
  
　クロージャーは FIX で宣言されるすべての関数に共用されるため
　binds に含まれる free-vars をまずは列挙する。

  しかし、これは上の FIX ですでに heap 済みかもしれない
　つまり入れ子になっている FIX の場合は親の FIX での free-vars は
  そこと共用される。

  そこで、いままで登録された FIX[S/H] を env から逆順にたどり
  そこにはいっていたら free-vars から削る

  結果として該当する FIX での free-vars のみがわかる。
  (同じ変数は上位の FIX で共有する。違う階層の共有)

  この heap を FIX(SもHも) FIX の本体の先頭で作る。
  recored-ref は関数内の先頭ですべてのクロージャ内の宣言している。
  FIXS ではすべて使われるはずなので使われいことをチェックしていない。
  FIXH では使われていない変数は recored-ref しないようチェックしている。
  
  使う際には fixs の場合はすぐに bind のなかでレジスタに復元して pop する。

  fixh ならさらにその一つの bind のなかで free-vars を探し
  bind 内の先頭で record-ref する。app は最後まで行かないとないので
  ここで record-ref してもスレッド対応を考えてもそれでよい。
　もし、厳密には致したいなら OS などで mutex を使わなくてはならないが
　コンパイラの仕事ではないので対応しない。

  どのタイミングで参照される"べき"かはコンパイラは知りようがないので
  FIXで定義される関数本体の最初で record-ref して問題ない。
  record-ref は遅延させて参照した方がよい場合もあるだろうが、
　これらはのちのスケジューリングで最適化されるのでここでは考慮しない。

  また fixh では該当する fixh に複数の bind があった場合に共有する
  (同階層の共有)
　そのため fixh では heap が二段階になっている。
  たとえば
  (FIXH ((f0 (a0 a1) (..... v0 .....))
         (f1 (a0 a1) (..... v1 .....)))
        (..FIX本体..))
  で v0 v1 が free-vars なら
  (heap ((:dummy) v0 v1) (|sym0|) ((....)))
  が生成される。さらに f0 と f1 のクロージャが生成され
  (heap ((:dummy v0 v1) (|sym0|)
    ((heap ((:label |f0|) |sym0|) (f0)
      ((heap ((:label |f1|) |sym0|) (f1)
         ((..FIX本体..))))))))
  となる。
  なお 関数が一つであった場合は 1つにする最適化をしている。
  (heap ((:label |f0-only|) v0 v1) (f0-only)
     ((..FIX本体..)))

  上位に FIXH があった場合はさらに複雑になるここでは簡略化して説明する
  (FIXH ((f0 (a0 a1) (..... v0 .....)))
      (..  FIX本体 f0 ...
         (FIXH ((f1 (a0 a1) (..... v0 ... v1 .....)))
            (..  FIX本体 f1 ...))))

   この場合 f1 の free-vars は v0 v1 だがすでに上位の v0 があるので
  (heap ((:label |f0|) v0 ) (f0)
        ((... FIX本体 f0)))
  というクロージャが存在する。
　そこで f1 のクロージャーは
    (heap ((:label |f1|) v1 f0 ) (f1)
          ((... FIX本体 f1)))
  となる。
　参照する際は
   (record-ref (f1 1) (v1)
    ((recored-ref (f1 2) (f0) 
      ((recored-ref (f0 1) (v0)
          ((.... v0 ..... v1 ....)))))
  となる。
  これで fixh に複数の関数定義があるとさらに複雑化されるが
  すべて事前にわかることなのでコンパイラで対応可能である。
  さらに FIX で宣言される f1 などで変数が隠ぺいされていた場合

  (FIXH ((f0 (a0 a1) (..... v0 .....)))
      (..  FIX本体 f0 ...
         (FIXH ((f1 (a0 a1 v0) (..... v0 ... v1 .....)))
            (..  FIX本体 f1 ...))))

  例えば上の v0 は f1 内では自由変数ではない。
  そのためこれらの宣言がある場合は ((:primitive . op) ... v0....)
  という環境を用意して隠ぺいする。
  宣言は
  binds 内の　関数名、引数
  primitive の結果
  が考えられ、それが考慮されている。

  
