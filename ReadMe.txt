2015年 12月 25日 金曜日 17:22:35 JST
    cps-transfer ほぼ決着
    set! とかができないが
        set! は構文糖衣でできそうな気がする。
    なにを最小構成にするのかは scheme の規約で確認すべき。
    本格的な scheme を目指す。

    cps-interp で動作させる
        => cps callback をつくるべき
    結果として NEON を含む ARM のオブジェクトを生成し
    ARM Linux で動かすのがここの目標。

----------------------------------------------------------------
ISSUES

define はスコープ破り
set! はスコープ破り(set! には対応していないが)
define は
    グローバル変数に対応しているのか？
    レジスタに対応しているのか？

IDEA
    (let ((io (heap-io 0xc0000000 0x1000)))
      (fixh ((get-uart-status () (record-ref io 0))
             (putc (c) (record-set! io 1 c))
             (getc () (record-ref io 1))
             (puts0 (str pos)
                    (let ((c (record-ref str pos)))
                      (if (= c 0)
                        :#t
                        (begin
                          (putc c)
                          (puts (str (+ pos 1)))))))
             (puts (str) (puts0 str 0))))
        ....
        ....
        (let ((hello (heap "Hello")))
            (puts hello)))
        ....

コンパイル時に登録された io を変換。
どうよ？

----------------------------------------------------------------
----------------------------------------------------------------
ほんとの ReadMe.txt のはじまり

----------------------------------------------------------------
とりあえず自分の CPS の勉強用に作る。

まずは lisp インタプリタを作り、
cps インタプリタを作り、
その後 cps 変換器をつくる。
「コンパイラ作成実験資料」という 1996 年のとある大学の 実習(?)資料を
元に作っている。とはいえ、勝手な解釈をして変更もしている。

----------------------------------------------------------------

lisp-v1 普通に作ったらダイナミックスコープになってしまった。
lisp-v2 クロージャを入れた。
        v1 と v2 で環境(*env* 本当は context)の形式が違うのに注意
        v1 は (a b) で v2 が (a . b)

----------------------------------------------------------------
cps-interp: cps の インタプリタ
    クロージャーに対応したつもり。
    テストが不十分
    cps 変換が出来たら検証用に必要だと思って作った。
    がいまだ必要とされず。

cps-transfer-naive: 効率の悪いバージョンかつ let および define を実装せず
    ある程度で来た
        -> if が重複を作る
        -> id がいっぱいできる
        -> let の実装がない
    とはいえここまでで終わり。
    lisp のマクロの使い方がおかしい。
    後を cps-transfer に引き継ぐ。

    fix も 関数内の cps が 1 cps と限定的。
    なお lisp の fix は begin を意味的に含むが
    cps の方は begin を含まない(やや混乱気味)
    heap もないや、、、
    だいぶあやしい
    let がない。
    id がいっぱいできる。
    lisp のマクロを理解していないころのものなので不必要な copy-tree が
    随所にある。

cps-transfer: 作り始めた
    let はトリッキーだがうまくいっている模様
    cps-transfer/ReadMe.txt を参照

eta-reduction: cps-eta-reduction: 簡単バージョンができた。
    これはこれでおしまい。
    出来ている模様。

    clousure 変換。やっていたと ReadMe.txt に書いてあったが存在しなかった。
    closure ？イギリス的には clousure かも。:w
    cps-interp で clousure に対応したと書かれている。
