----------------------------------------------------------------
衝撃的な結論(2016年 2月 14日 日曜日 01:27:08 JST)
CPS より A正規化、A正規化より K正規化の方がよいらしい。
ひと段落ついたら A正規化にも移行する。

自分の CPS の勉強用に作る。
コンパイラの生成過程をわかりやすく表示できるようにしたい。

「コンパイラ作成実験資料」という 1996 年のとある大学の 実習(?)資料を
元に CPS の勉強をしている。資料を元にしてはいるが勝手な解釈をして
変更している。

最終目標は ARM コンパイラと NEON 対応。
scheme 的には mini-scheme じゃなくて仕様に沿った scheme を目指す。
ってかこのまま common lisp 上でいいのか？

----------------------------------------------------------------
あと cps-transfer の record-set!-transfer 
  `(:RECORD-SET! (RECORD-NAME ARG0 ARG1) 
scm-script で統一されてない気がする。
(:record-set! record-name offset value) が正しい。
あとこれを CPS に直すと
(:record-set! (record-name offset value) () ((....))
になる。
途中で混乱している。
----------------------------------------------------------------
2016年 2月 12日 金曜日 00:55:15 JST
進捗
    cps-compiler として統合して vmgen で作った VM の上で動いた。
    spill と define にバグがあるようだ。
    今後はグローバル関数・変数対応に力を入れる。
    cps-compiler 

    testsuite が圧倒的に足りない。

    k-transfer ある程度安定してきた。ただし、今の仕組みでは限界も見えている。
    ソースの汚さを棚に上げておくと、、、Oも棚に上げ置いて、、、、
    技術的には、、、、
    とくに stack/pop のところ。無駄に stack して連続的な record-ref により
    レジスタを最初に占有してしまう。record-ref のレジスタ占有により
    レジスタ数が足りなくなり spill が必要にある。
    今の仕組みの spill はバグがあり対応できていないようだ。

    stack も heap もある意味仮想レジスタと言えるので直前に record-ref という
    戦略もあり得る。ただし、単純に直前にすると本当の CPU ではパイプラインを
    ストールさせる可能性もある。最近の CPU は reorder するからいいともいえる。
    どのタイミングで record-ref したらよいかは record-ref にかかる
    レイテンシーにもよる。特に NEON(ARMv7) はどうやらちゃんとコンパイラで
    順序も決めてやらないとパイプラインが乱れるようなので(未確認)
    コンパイラのサポートが必須。ARMv8 で改良されたのかな？

    order の最適化が効くと望ましく、一応つくってあるが、機能してなさそう。
    (わざわざそのために作ったのだが、、、機能しているかどうか確認できない)

    将来的には GC や float/double のサイズが問題になることは明らか。
    浮動小数点は型推定が必要になるだろう。
    boxing(boxed?) するのか？
    ML や GHC(Haskellのコンパイラ) を参考にすべき？
    Standard ML of New Jersey を参考にすべき？
    MiniOcaml を発見したのでそちらを参考にすべきかもしれない。
    噂の stalin も型推定で参考にしたい。

    中途半端な cl のパッケージ化がなされている

    lisp インタプリタ => とりあえず完成
    cps-interp    => closure をちゃんと実装していない
    cps-transfer  => とりあえず完成
    eta-reduction => とりあえず完成
    k-transfer    => とりあえず完成
    resource-scheduler => ベースとしては完成
    cps-reorder   => とりえあえず完成
    cps-live-variables-finder => とりあえず完成
    cps-spill => とりあえず完成
    vm-codegen => とりあえず完成
    vmgen => バイナリ化してとりあえず完成
    cps-compiler => とりあえず完成

今後
    ARM 対応
    NEON 対応
        浮動小数点のために型推定が必要になる？
    PolyPhony IR 対応
    IROHA 対応
    
    R4RS 対応
        symbol や ストリングを実装予定。
        その際には抽象的にしてなるべく後のフェーズで実装として解決する。
        例えば、symbol/ストリングを heap してしまうと malloc 的な技術に
        ストリングが固定されてしまい、HLS への対応が難しくなる。

----------------------------------------------------------------
以下、各ディレクトリ簡単に説明
----------------------------------------------------------------

lisp-v1 普通に作ったらダイナミックスコープになってしまった。
lisp-v2 クロージャを入れた。
        v1 と v2 で環境(*env* 本当は context)の形式が違うのに注意
        v1 は (a b) で v2 が (a . b)

----------------------------------------------------------------
cps-interp: cps の インタプリタ
    クロージャーに対応したつもり。
    テストが不十分
    cps 変換が出来たら検証用に必要だと思って作った。
    がいまだ必要とされず。

    cps-interp の closure
        fix がきたら えせ closure を作って table に登録している
        ちゃんと自由変数を見ていない=>bug.
        closure 変換をしているわけではない
        fix が来たらちゃんと自由変数をみて
        closure を作るのが closure 
        いまは fix の引数をつくっているだけ。

cps-transfer-naive: 効率の悪いバージョンかつ let および define を実装せず
    ある程度で来た
        -> if が重複を作る
        -> id がいっぱいできる
        -> let の実装がない
    とはいえここまでで終わり。
    lisp のマクロの使い方がおかしい。
    後を cps-transfer に引き継ぐ。

    fix も 関数内の cps が 1 cps と限定的。
    なお lisp の fix は begin を意味的に含むが
    cps の方は begin を含まない(やや混乱気味)
    heap もないや、、、
    だいぶあやしい
    let がない。
    id がいっぱいできる。
    lisp のマクロを理解していないころのものなので不必要な copy-tree が
    随所にある。

cps-transfer:
    let はトリッキーだがうまくいっている模様
    だいたいで来た
    cps-transfer/ReadMe.txt を参照

eta-reduction:
    ηリダクションの最適化をする
    ちゃんと walk-cps して確認している。
    関数 check-eta-reduction をより厳密にチェックすべきか？
        optimize.lisp は walk-cps していないのでチェックが厳しい。
        walk-cps しているので cps の構文が崩れていないという前提に
        たてば今のままでよいはず。つまり optimize.lisp はいらない。
    簡単バージョン(n-reduction) を発展させて完成させた。
    これはこれでおしまい。
    関数 n-reduction は削除してよい。

resource-scheduler
    リソース管理用のクラス
    リストスケジューリングを採用
    汎用的にしようと思ったがかなり場当たり的

cps-reorder
    ブロック内のインストラクションの順序入れ替え
    ヒューリスティックな方法
    resource-scheduler を使っている。そのため O(N^2) だぜ

cps-live-variables-finder
    変数の生き死にをブロックごとに見つける。
    free variables を見つけるルーチンがすでにあるのに、、、

k-transfer
    クロージャー変換
    k-transfer 時の record-offs に対応した。
    docment がまだ追いついていない。

    record-offs を途中まで知らなかったので右往左往することに
    現在は record-offs を使ってのクロージャの共有を達成
    また、record-offs にマイナスを許せば、さらにコードは
    簡略化することが出来るのに後で気が付いた。
        恐らく、heap の前後に magic をいれ、
        各 binds の前に binds が何番目の binds かをダミーコードとして
        いれておけば、heap サイズのチェックは容易になるはず。
    FIX の多重層によるクロージャの共有はかなり怪しい。


cps-spill
    スピル処理
    cps-live-variables-finder を利用。そのため O(N^2) だぜ
    -----------------------------------------
    対応したつもり
    FIXH で宣言された引数をすべて spill の対象にしている
    引数も生き死にを調べて、つかっていない引数は対象に
    含めないようにしないと、f(a0 a1 ... an) で n が spill の
    対象数を超えると何も考えずに spill してしまう。
    -----------------------------------------

vm-codegen
    簡単なバーチャルマシン生成。ただし vm 自身がまだない。
    生成されるジャンプ命令が多すぎるができた模様。

cps-compiler
    cps-transfer
    cps-reorder
    k-transfer
    cps-spill
    vm-codegen
    までを連続して行う。連続して行うもそれぞれが連動しておらず、
    意味なく cps-live-variables-finder が２回呼ばれる上に
    別に free variables を見つけるルーチンあるのでかなり冗長
    だが、動く!!
    
vmgen
    32bitバイナリをはくことが出来るようになった。
    その代償として、中間的に vmgen 対応の C ソースを作っていたが
    その機能を失った。

    (:LABEL MAIN) は配列の添え字番号とした。
    (:ADDRESS EXIT) は実際に実行するマシンのアドレスになるべきで
    実行時に動的に変換されなければならない。  
    (:INSTRUCTION "jump") は VM 上の goto のラベルに対応するので
    実行時に動的に変換されなければならない。  
    これらの変換が可能なような情報を持つバイナリになっている。

vmgen/hvm
    gforth の vmgen で作られた VM。
    上記 vmgen の出力を入力とし、必要な変換をして実行する。
    すべてのオペコードに対応していない。
    conditional jump は大抵 eqi8 の後にあるので peephole で最適化するか
    VM で goto しないように(連続するようにしておく)した方がいいだろう。
    動かした実績があるのは Linux 64bit 環境
    32bit 環境でちゃんと動くかどうかは不明。
----------------------------------------------------------------
ひとりごと、vx-scheme に追いつけ追い越せ。

vx-scheme をみると stack 操作と heap の間でかなり複雑なことをしている。
これは stack 内にオブジェクトがあると GC の対象としてみなすことが
難しいからだ。かりに GC の対象になったとして copying GC だと
動かせない stack 内のオブジェクトはどう扱うのか？

この CPS も stack は使っておりブロック内で必ず開放するとは限らない。
むしろ複数のブロックにまたがる。(FIXS 内でペアになっている)
stack も heap にとるように改良したいがそうすると GC が必要になる。
stack はブロック内で解放されないので GC の対象にならない。

基本的に stack/pop は FIXS で内でペアーで使われる。
ところが現在の作りだと、複数の FIXS 並んであった場合(入れ子ではなく)
無駄に stack/pop を繰り返す。これが heap になると無視できなくなるほど
性能劣化を引き起こす原因(と予測される。未調査)
FIXS に先立ち関数があるはずである。つまり FIXS か define か main がある。
その先頭で含まれるすべての FIXS 内の自由変数をとらえ 
fp から参照できるようにし、fp を使いまわすことで stack/pop を
繰り返すことを抑制可能である。関数から戻る際に fp から pop する。
これを使うとそもそも FIXS の性能劣化はひき起きないと思われる。
したがって、heap でも大丈夫なはず(GC されないという欠点はあるが)。

つまりこれはローカル変数のフレームづくり。
ARM が連続して push/pop 出来る意味が分かった
(恐らく AXI の バースト転送を考慮している)

GC は app の最初で行われる。
GC のために ブロック内での heap で取得される量がわかることは重要
Java の VM で heap 量をあらかじめとっておいたりしている理由がそこにある。
stack なしで heap ですべて実行する方がよいかもしれない。 (GC 的に)。
そうすると Real Time な処理に対応できない気もするが。
mruby はどうなっているのだろう?

後でわかったことだが、私が参照していた資料の改良版のページがあることに
気が付いた。
改良点は APPF と APPB というものの導入したようだ。
FIXS は相変わらずあるので stack は使用している模様。
CPS の文法上は POP あるようだが、資料の出力するコードからは POP が消えている。
pop は APPB の直前で fp を使っておこうのか？(詳細不明)
pop はあるがどう使っているかは明示されていないように思える。(読み落とし?)

さらに MiniOcaml を作るという型推定をした版が別の人によって
試みがなされていることもわかった。こちらは CPS ではなくて A か K 正規化。
