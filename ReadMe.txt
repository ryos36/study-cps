----------------------------------------------------------------
自分の CPS の勉強用に作る。

「コンパイラ作成実験資料」という 1996 年のとある大学の 実習(?)資料を
元に CPS の勉強をしている。資料を元にしてはいるが勝手な解釈をして
変更している。

最終目標は ARM コンパイラと NEON 対応。

----------------------------------------------------------------
2016年 1月 21日 木曜日 18:19:45 JST
進捗
    lisp インタプリタ => とりあえず完成
    cps-interp    => closure をちゃんと実装していない
    cps-transfer  => とりあえず完成
    eta-reduction => とりあえず完成
    k-transfer    => とりあえず完成
    resource-scheduler => ベースとしては完成
    cps-reorder   => 実装中

今後
    スピル対応
    VM 対応
    ARM 対応
    NEON 対応
    polyphony IR 対応
    IROHA 対応

----------------------------------------------------------------
以下、各ディレクトリ簡単に説明
----------------------------------------------------------------

lisp-v1 普通に作ったらダイナミックスコープになってしまった。
lisp-v2 クロージャを入れた。
        v1 と v2 で環境(*env* 本当は context)の形式が違うのに注意
        v1 は (a b) で v2 が (a . b)

----------------------------------------------------------------
cps-interp: cps の インタプリタ
    クロージャーに対応したつもり。
    テストが不十分
    cps 変換が出来たら検証用に必要だと思って作った。
    がいまだ必要とされず。

    cps-interp の closure
        fix がきたら えせ closure を作って table に登録している
        ちゃんと自由変数を見ていない=>bug.
        closure 変換をしているわけではない
        fix が来たらちゃんと自由変数をみて
        closure を作るのが closure 
        いまは fix の引数をつくっているだけ。

cps-transfer-naive: 効率の悪いバージョンかつ let および define を実装せず
    ある程度で来た
        -> if が重複を作る
        -> id がいっぱいできる
        -> let の実装がない
    とはいえここまでで終わり。
    lisp のマクロの使い方がおかしい。
    後を cps-transfer に引き継ぐ。

    fix も 関数内の cps が 1 cps と限定的。
    なお lisp の fix は begin を意味的に含むが
    cps の方は begin を含まない(やや混乱気味)
    heap もないや、、、
    だいぶあやしい
    let がない。
    id がいっぱいできる。
    lisp のマクロを理解していないころのものなので不必要な copy-tree が
    随所にある。

cps-transfer:
    let はトリッキーだがうまくいっている模様
    だいたいで来た
    cps-transfer/ReadMe.txt を参照

eta-reduction:
    ちゃんと walk-cps して確認している。
    関数 check-eta-reduction をより厳密にチェックすべきか？
        optimize.lisp は walk-cps していないのでチェックが厳しい。
        walk-cps しているので cps の構文が崩れていないという前提に
        たてば今のままでよいはず。つまり optimize.lisp はいらない。
    簡単バージョン(n-reduction) を発展させて完成させた。
    これはこれでおしまい。
    関数 n-reduction は削除してよい。

rec-opt
    ;'(FB (0 1) (1 1) (N (+ (FB (- n 1)) (FB (- n 2)))))
    の最適化
    FIBO に似た形の関数を最適化して末尾呼び出しにしようという試み
    アイデアだけ

