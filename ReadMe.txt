2015年 12月 31日 木曜日 12:10:21 JST
    cps-transfer ほぼ決着
    eta-reduction もちゃんとやっていた。

    cps-interp で動作させる
        => cps callback をつくるべき
    結果として NEON を含む ARM のオブジェクトを生成し
    ARM Linux で動かすのがここの目標。

    cps-interp の closure
        fix がきたら えせ closure を作って table に登録している
        ちゃんと自由変数を見ていない=>bug.
        closure 変換をしているわけではない
        fix が来たらちゃんと自由変数をみて
        closure を作るのが closure 
        いまは fix の引数をつくっているだけ。

----------------------------------------------------------------
CPS についての覚書(すぐ忘れるから)

(:+ (1 3) (x) ((:+ (x 4) (rv) ((....)))))
              ^^              ^^
に括弧が多い気がするがこれでよい。
CPS は 
(PRIMSYM (OP*) (ID*) (CPS*))
となっている。OP が比較でないとき(+ などのとき)
は 
(PRIMSYM (OP*) (ID*) (CPS))
                     ^^^^^
となりCPS はひとつ。CPS の外側に() が余計にある。
比較の時は
(PRIMSYM (OP*) (ID*) (CPS0 CPS1))
                     ^^^^^^^^^^^
となり CPS は２つ。比較の時とそうでない時で
統一するために括弧が一つ多い。

----------------------------------------------------------------
ISSUES

scheme には /= がなかった

    mini-scheme では
    set! とかができないが
        set! は構文糖衣でできそうな気がする。
    なにを最小構成にするのかは scheme の規約で確認すべき。
    本格的な scheme を目指す。

define はスコープ破り
set! はスコープ破り(set! には対応していないが)
define は
    グローバル変数に対応しているのか？
    レジスタに対応しているのか？

closure ？イギリス的には clousure かも。

IDEA
    (let ((io (heap-io 0xc0000000 0x1000)))
      (fixh ((get-uart-status () (record-ref io 0))
             (putc (c) (record-set! io 1 c))
             (getc () (record-ref io 1))
             (puts0 (str pos)
                    (let ((c (record-ref str pos)))
                      (if (= c 0)
                        :#t
                        (begin
                          (putc c)
                          (puts (str (+ pos 1)))))))
             (puts (str) (puts0 str 0))))
        ....
        ....
        (let ((hello (heap "Hello")))
            (puts hello)))
        ....

コンパイル時に登録された io を変換。
どうよ？

IDEA その２
    シンタックス・チェック用の汎用的なマクロ化関数を作るべき？
    現時点では cps になった時点でシンタックスに間違いがない
    という仮定をしている。これはこれでよい（スピードが上がるから)
    scheme 側でシンタックスを見るべき。
    デバッグ用にシンタックスをみる。
    シンタックス・チェック言語って
        構文定義を入れたら、そのコールバックが呼ばれる
        トップ関数をつくる関数だよね。

        なんかどっかにありそうなんだけど、、、

----------------------------------------------------------------
----------------------------------------------------------------
ほんとの ReadMe.txt のはじまり

----------------------------------------------------------------
とりあえず自分の CPS の勉強用に作る。

まずは lisp インタプリタを作り、
cps インタプリタを作り、
その後 cps 変換器をつくる。
「コンパイラ作成実験資料」という 1996 年のとある大学の 実習(?)資料を
元に作っている。とはいえ、勝手な解釈をして変更もしている。

----------------------------------------------------------------

lisp-v1 普通に作ったらダイナミックスコープになってしまった。
lisp-v2 クロージャを入れた。
        v1 と v2 で環境(*env* 本当は context)の形式が違うのに注意
        v1 は (a b) で v2 が (a . b)

----------------------------------------------------------------
cps-interp: cps の インタプリタ
    クロージャーに対応したつもり。
    テストが不十分
    cps 変換が出来たら検証用に必要だと思って作った。
    がいまだ必要とされず。

cps-transfer-naive: 効率の悪いバージョンかつ let および define を実装せず
    ある程度で来た
        -> if が重複を作る
        -> id がいっぱいできる
        -> let の実装がない
    とはいえここまでで終わり。
    lisp のマクロの使い方がおかしい。
    後を cps-transfer に引き継ぐ。

    fix も 関数内の cps が 1 cps と限定的。
    なお lisp の fix は begin を意味的に含むが
    cps の方は begin を含まない(やや混乱気味)
    heap もないや、、、
    だいぶあやしい
    let がない。
    id がいっぱいできる。
    lisp のマクロを理解していないころのものなので不必要な copy-tree が
    随所にある。

cps-transfer:
    let はトリッキーだがうまくいっている模様
    だいたいで来た
    cps-transfer/ReadMe.txt を参照

eta-reduction: cps-eta-reduction:
    ちゃんと walk-cps して確認している。
    関数 check-eta-reduction をより厳密にチェックすべきか？
        optimize.lisp は walk-cps していないのでチェックが厳しい。
        walk-cps しているので cps の構文が崩れていないという前提に
        たてば今のままでよいはず。つまり optimize.lisp はいらない。
    簡単バージョン(n-reduction) を発展させて完成させた。
    これはこれでおしまい。
    関数 n-reduction は削除してよい。

