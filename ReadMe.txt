----------------------------------------------------------------
自分の CPS の勉強用に作る。

「コンパイラ作成実験資料」という 1996 年のとある大学の 実習(?)資料を
元に CPS の勉強をしている。資料を元にしてはいるが勝手な解釈をして
変更している。

最終目標は ARM コンパイラと NEON 対応。
scheme 的には mini-scheme じゃなくて仕様に沿った scheme を目指す。
ってかこのまま common lisp 上でいいのか？

----------------------------------------------------------------
2016年 2月  4日 木曜日 08:50:46 JST
進捗
    VM コードも多分できた。testsuite が圧倒的に足りない。

    k-transfer ある程度安定してきた。ただし、今の仕組みでは
    限界も見えている。

    k-transfer 時の record-offs に対応した。
    docment がまだ追いついていない。

    将来的には GC や float/double のサイズが問題になることは明らか。
    浮動小数点は型推定が必要になるだろう。
    boxing(boxed?) するのか？
    ML や GHC(Haskellのコンパイラ) を参考にすべき？
    Standard ML of New Jersey を参考にすべき？

    中途半端な cl のパッケージ化がなされている

    lisp インタプリタ => とりあえず完成
    cps-interp    => closure をちゃんと実装していない
    cps-transfer  => とりあえず完成
    eta-reduction => とりあえず完成
    k-transfer    => とりあえず完成
    resource-scheduler => ベースとしては完成
    cps-reorder   => とりえあえず完成
    cps-live-variables-finder => とりあえず完成
    cps-spill => とりあえず完成
    vm-codegen => とりあえず完成
    vmgen => 対応中

今後
    ARM 対応
    NEON 対応
        浮動小数点のために型推定が必要になる？
    PolyPhony IR 対応
    IROHA 対応
    
    R4RS 対応

----------------------------------------------------------------
以下、各ディレクトリ簡単に説明
----------------------------------------------------------------

lisp-v1 普通に作ったらダイナミックスコープになってしまった。
lisp-v2 クロージャを入れた。
        v1 と v2 で環境(*env* 本当は context)の形式が違うのに注意
        v1 は (a b) で v2 が (a . b)

----------------------------------------------------------------
cps-interp: cps の インタプリタ
    クロージャーに対応したつもり。
    テストが不十分
    cps 変換が出来たら検証用に必要だと思って作った。
    がいまだ必要とされず。

    cps-interp の closure
        fix がきたら えせ closure を作って table に登録している
        ちゃんと自由変数を見ていない=>bug.
        closure 変換をしているわけではない
        fix が来たらちゃんと自由変数をみて
        closure を作るのが closure 
        いまは fix の引数をつくっているだけ。

cps-transfer-naive: 効率の悪いバージョンかつ let および define を実装せず
    ある程度で来た
        -> if が重複を作る
        -> id がいっぱいできる
        -> let の実装がない
    とはいえここまでで終わり。
    lisp のマクロの使い方がおかしい。
    後を cps-transfer に引き継ぐ。

    fix も 関数内の cps が 1 cps と限定的。
    なお lisp の fix は begin を意味的に含むが
    cps の方は begin を含まない(やや混乱気味)
    heap もないや、、、
    だいぶあやしい
    let がない。
    id がいっぱいできる。
    lisp のマクロを理解していないころのものなので不必要な copy-tree が
    随所にある。

cps-transfer:
    let はトリッキーだがうまくいっている模様
    だいたいで来た
    cps-transfer/ReadMe.txt を参照

eta-reduction:
    ηリダクションの最適化をする
    ちゃんと walk-cps して確認している。
    関数 check-eta-reduction をより厳密にチェックすべきか？
        optimize.lisp は walk-cps していないのでチェックが厳しい。
        walk-cps しているので cps の構文が崩れていないという前提に
        たてば今のままでよいはず。つまり optimize.lisp はいらない。
    簡単バージョン(n-reduction) を発展させて完成させた。
    これはこれでおしまい。
    関数 n-reduction は削除してよい。

resource-scheduler
    リソース管理用のクラス
    リストスケジューリングを採用
    汎用的にしようと思ったがかなり場当たり的

cps-reorder
    ブロック内のインストラクションの順序入れ替え
    ヒューリスティックな方法
    resource-scheduler を使っている。そのため O(N^2) だぜ

cps-live-variables-finder
    変数の生き死にをブロックごとに見つける。
    free variables を見つけるルーチンがすでにあるのに、、、

k-transfer
    クロージャー変換
    record-offs を途中まで知らなかったので右往左往することに
    現在は record-offs を使ってのクロージャの共有を達成
    また、record-offs にマイナスを許せば、さらにコードは
    簡略化することが出来るのに後で気が付いた。
        恐らく、heap の前後に magic をいれ、
        各 binds の前に binds が何番目の binds かをダミーコードとして
        いれておけば、heap サイズのチェックは容易になるはず。
    FIX の多重層によるクロージャの共有はかなり怪しい。

cps-spill
    スピル処理
    cps-live-variables-finder を利用。そのため O(N^2) だぜ
    -----------------------------------------
    対応したつもり
    FIXH で宣言された引数をすべて spill の対象にしている
    引数も生き死にを調べて、つかっていない引数は対象に
    含めないようにしないと、f(a0 a1 ... an) で n が spill の
    対象数を超えると何も考えずに spill してしまう。
    -----------------------------------------

vm-codegen
    簡単なバーチャルマシン生成。ただし vm 自身がまだない。
    生成されるジャンプ命令が多すぎるができた模様。

vmgen
    gforth の vmgen と連携して C の実行形式を作ることが出来る。
    vm 自動生成ツール(になるはず)
----------------------------------------------------------------
ひとりごと、vx-scheme に追いつけ追い越せ。

vx-scheme をみると stack 操作と heap の間でかなり複雑なことをしている。
これは stack 内にオブジェクトがあると GC の対象としてみなすことが
難しいからだ。かりに GC の対象になったとして copying GC だと
動かせない stack 内のオブジェクトはどう扱うのか？

この CPS も stack は使っておりブロック内で必ず開放するとは限らない。
むしろ複数のブロックにまたがる。
GC は app の最初で行われる。
GC のために ブロック内での heap で取得される量がわかることは重要
Java の VM で heap 量をあらかじめとっておいたりしている理由がそこにある。
stack なしで heap ですべて実行する方がよいかもしれない。 (GC 的に)。
そうすると Real Time な処理に対応できない気もするが。
mruby はどうなっているのだろう?

後でわかったことだが、私が参照していた資料の改良版のページがあることに
気が付いた。上記の問題がやはり CPS にある。
つまり stack は使っていてブロック内で解放されないので GC の対象に
ならないということ。そこでどうやら stack も heap にとるように
改良されたようだ(詳細未確認)。そして pop がなくなった?
stack は大きな root として扱うとある。pop はどうするのだ？APPB で
おこなうのか？詳細が不明だ。GC やっていくうち解決すると見込んでいる。
CPS の文法上はあるようだが、資料の出力するコードからは POP が消えている。
