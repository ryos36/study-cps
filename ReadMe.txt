----------------------------------------------------------------
自分の CPS の勉強用に作る。

「コンパイラ作成実験資料」という 1996 年のとある大学の 実習(?)資料を
元に CPS の勉強をしている。資料を元にしてはいるが勝手な解釈をして
変更している。

最終目標は ARM コンパイラと NEON 対応。
scheme 的には mini-scheme じゃなくて仕様に沿った scheme を目指す。
ってかこのまま common lisp 上でいいのか？

----------------------------------------------------------------
2016年 1月 27日 水曜日 14:27:40 JST
進捗
    今後は VM コードの生成へと進む

    将来的には GC や float/double のサイズが問題になることは明らか。
    boxing(boxed?) するのか？
    ML や GHC(Haskellのコンパイラ) を参考にすべき？
    Standard ML of New Jersey を参考にすべき？

    中途半端な cl のパッケージ化がなされている

    lisp インタプリタ => とりあえず完成
    cps-interp    => closure をちゃんと実装していない
    cps-transfer  => とりあえず完成
    eta-reduction => とりあえず完成
    k-transfer    => とりあえず完成
    resource-scheduler => ベースとしては完成
    cps-reorder   => とりえあえず完成
    cps-live-variables-finder => とりあえず完成
    cps-spill => とりあえず完成

今後
    VM 対応
    ARM 対応
    NEON 対応
        浮動小数点のために型推定が必要になる？
    PolyPhony IR 対応
    IROHA 対応
    
    R4RS 対応

----------------------------------------------------------------
以下、各ディレクトリ簡単に説明
----------------------------------------------------------------

lisp-v1 普通に作ったらダイナミックスコープになってしまった。
lisp-v2 クロージャを入れた。
        v1 と v2 で環境(*env* 本当は context)の形式が違うのに注意
        v1 は (a b) で v2 が (a . b)

----------------------------------------------------------------
cps-interp: cps の インタプリタ
    クロージャーに対応したつもり。
    テストが不十分
    cps 変換が出来たら検証用に必要だと思って作った。
    がいまだ必要とされず。

    cps-interp の closure
        fix がきたら えせ closure を作って table に登録している
        ちゃんと自由変数を見ていない=>bug.
        closure 変換をしているわけではない
        fix が来たらちゃんと自由変数をみて
        closure を作るのが closure 
        いまは fix の引数をつくっているだけ。

cps-transfer-naive: 効率の悪いバージョンかつ let および define を実装せず
    ある程度で来た
        -> if が重複を作る
        -> id がいっぱいできる
        -> let の実装がない
    とはいえここまでで終わり。
    lisp のマクロの使い方がおかしい。
    後を cps-transfer に引き継ぐ。

    fix も 関数内の cps が 1 cps と限定的。
    なお lisp の fix は begin を意味的に含むが
    cps の方は begin を含まない(やや混乱気味)
    heap もないや、、、
    だいぶあやしい
    let がない。
    id がいっぱいできる。
    lisp のマクロを理解していないころのものなので不必要な copy-tree が
    随所にある。

cps-transfer:
    let はトリッキーだがうまくいっている模様
    だいたいで来た
    cps-transfer/ReadMe.txt を参照

eta-reduction:
    ηリダクションの最適化をする
    ちゃんと walk-cps して確認している。
    関数 check-eta-reduction をより厳密にチェックすべきか？
        optimize.lisp は walk-cps していないのでチェックが厳しい。
        walk-cps しているので cps の構文が崩れていないという前提に
        たてば今のままでよいはず。つまり optimize.lisp はいらない。
    簡単バージョン(n-reduction) を発展させて完成させた。
    これはこれでおしまい。
    関数 n-reduction は削除してよい。

resource-scheduler
    リソース管理用のクラス
    リストスケジューリングを採用
    汎用的にしようと思ったがかなり場当たり的

cps-reorder
    ブロック内のインストラクションの順序入れ替え
    ヒューリスティックな方法
    resource-scheduler を使っている。そのため O(N^2) だぜ

cps-live-variables-finder
    変数の生き死にをブロックごとに見つける。
    free variables を見つけるルーチンがすでにあるのに、、、

cps-spill
    スピル処理
    cps-live-variables-finder を利用。そのため O(N^2) だぜ
    FIXH で宣言された引数をすべて spill の対象にしている
    引数も生き死にを調べて、つかっていない引数は対象に
    含めないようにしないと、f(a0 a1 ... an) で n が spill の
    対象数を超えると何も考えずに spill してしまう。
----------------------------------------------------------------
ひとりごと、vx-scheme に追いつけ追い越せ。

vx-scheme をみると stack 操作と heap の間でかなり複雑なことをしている。
これは stack 内にオブジェクトがあると GC の対象としてみなすことが
難しいからだ。かりに GC の対象になったとして copying GC だと
動かせない stack 内のオブジェクトはどう扱うのか？

この CPS でも stack は使っているがブロック内で必ず開放する。
そのため GC は app の最初で行われる。
GC のために ブロック内での heap で取得される量がわかることは重要
Java の VM で heap 量をあらかじめとっておいたりしている理由が
わかり始めた。
stack なしで heap ですべて実行する方がよいかもしれない。 (GC 的に)。
そうすると Real Time な処理に対応できない気もするが。
mruby はどうなっているのだろう?
